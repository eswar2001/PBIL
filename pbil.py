# -*- coding: utf-8 -*-
"""PBIL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17l8dlixXarEz625oSvuF6lyNFCqeNsaY
"""

import numpy as np
import cv2
import pywt
from PIL import Image, ImageFilter
import random
import math
import cmath
from scipy.fftpack import dct
from scipy.fftpack import idct
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow
import time
import os
import statistics
import urllib.request
import threading

sdl = []
class PBIL1(object):
    def __init__(self,original_image,Image_after_idct,n=5,m=5,adaptive=False,iterations=1000,lr=0.2,ms=0.05,range=1):
        self.PV=np.full((1,m),0.5)
        self.n=n
        self.m=m
        self.imgMAT = original_image ## np.random.uniform(low=0.0, high=255.0,size=(n,m)) #Should be given through constructor
        self.pop = np.random.choice(2,self.n*self.m,self.PV.tolist()).reshape(self.n,self.m)
        self.TimgMAT = Image_after_idct #np.random.uniform(low=0, high=0,size=(n,m)) #given imgMAT to be TRUNC 
        self.fitness= np.zeros(self.n)
        self.best_chromosome_index= -1
        self.best_chromosome_list = np.array
        self.best_chromosome_lists = []
        self.LR= lr
        self.MS= ms
        self.range = range
        self.sd=[]
        self.adaptive=adaptive
        self.iterations=iterations

    def adaptive_lr(self,i,j):
        self.LR=self.LR*(i/j)
    
    def printData(self):
        print('Probability_vector=\n',self.PV)
        print('Population=\n',self.pop)
        print('Image=\n',self.imgMAT)
        print('Translated/Truncated Image=\n',self.TimgMAT)
        print('fitness=\n',self.fitness,end="\n")
        print('Best Chromosomes possible = ',self.best_chromosome_list)

    def translateImg(self):
        # print(self.pop)
        for i in range(self.n):
            for j in range(self.m):
                if self.pop[i][j]==1:
                    # print(self.TimgMAT[i][j])
                    self.TimgMAT[i][j] = np.round((self.imgMAT[i][j]))+1
                else:
                    self.TimgMAT[i][j] = np.round((self.imgMAT[i][j]))
    
    def calculate_fitness(self):
        self.fitness=np.zeros(self.n) # resetting fitness matrix to zero
        for i in range(self.n):
            for j in range(self.m):
                self.fitness[i]+=abs(self.TimgMAT[i][j] - self.imgMAT[i][j])
        self.best_chromosome_index = np.where(self.fitness == np.amin(self.fitness))
        self.best_chromosome_list=[i for i in self.pop[self.best_chromosome_index[0]].tolist()]
        
        for j in range(-self.range,self.range):
          for k in np.where(self.fitness == (np.amin(self.fitness)+j)):
            for i in k:
              self.best_chromosome_lists.append(self.pop[i].tolist())
        # print('Best Chromosomes list = \n',self.best_chromosome_lists)

        # print('Best Chromosomes possible = ',self.best_chromosome_list)
    
    def update_PV(self):
        Solution_Vector = np.zeros(len(self.best_chromosome_list[0]))
        for i in self.best_chromosome_lists:
          for j in range(len(i)):
            Solution_Vector[j] += (i[j] * 1/len(self.best_chromosome_lists))
       
        for i in range(len(self.PV)):
            self.PV[i]=self.PV[i]*(1-self.LR)+Solution_Vector[i]*self.LR
#         print('updated PV',self.PV)
        
    def mutate_PV(self):
        for i in range(len(self.PV)):
            self.PV[i]=self.PV[i]*(1-self.MS)+random.randint(0, 1)*self.LR
#         print('mutated PV',self.PV)

    def run(self):
        j=1
        while(True):
            j = j+1
            if j==self.iterations+1:
                sdl.append(self.sd)
                return self.TimgMAT
            if self.adaptive:    
                self.adaptive_lr(j,self.iterations+1)
            self.pop= np.random.choice(2,self.n*self.m,self.PV.tolist()).reshape(self.n,self.m)
            self.translateImg()
            self.calculate_fitness()
            self.update_PV()
            self.mutate_PV()
            BC=self.best_chromosome_list
            # self.printData()
            tmp=statistics.stdev(self.fitness.tolist())
            # print(self.fitness.tolist())
            self.sd.append(tmp)
            # print('Iteration',j,'\n Fitness Value=',tmp)
            # print()
            if len(BC)==self.n and np.amin(self.fitness)<=0:
                return self.TimgMAT

urllib.request.urlretrieve("https://i.ibb.co/kQKsYPg/mandril.png", "/content/mandril.png")
urllib.request.urlretrieve("https://i.ibb.co/C53Xn21/lena.png", "/content/lena.png")
img = Image.open('/content/mandril.png').convert('LA')
img.save('/content/greyscale.png')
watermark = cv2.imread('/content/greyscale.png', 0)
host = cv2.imread('/content/lena.png', 0)
N,M=256,256
P,Q=100,100


try:
 a = cv2.resize(host,(N,M))
 b = cv2.resize(watermark,(P,Q)) #np.random.choice(2,P*Q,[0.5]*P).reshape(P,Q)
#  print(b) #cv2.resize(watermark,(P,Q))
except:
  print('e')

# Uncomment this for binary matrices insted of images 
# a=np.random.choice(2,N*M,[0.5]*N).reshape(N,M)
# b=np.random.choice(2,P*Q,[0.5]*P).reshape(P,Q)

print('Water Mark')
plt.imshow(b)
plt.show()


print('Image')
plt.imshow(a)
plt.show()

d=dct(a)
c=d

for i in range(0,P):  ##Hiding image to upper left corner
  for j in range(0,Q):
    c[i][j]+=b[i][j]

e=idct(c)

print('After IDCT')
plt.imshow(e)
plt.show()

print('Original matrix \n',a)
# print('DCT Original matrix \n',d)
# print('IDCT a without watermark \n',idct(d))
# print('Watermark \n',b)
# print('after adding the watermark',c)
print('matrix after IDCT \n',e)
g = PBIL1(a,e,N,M,True,500) ##Adaptive Learning Rate
h = PBIL1(a,e,N,M,False,500) ##Static Learning Rate


afterimg = g.run()
print('matrix after PBIL \n',afterimg)
plt.imshow(afterimg)
plt.show()


afterimg = h.run()
print('matrix after PBIL \n',afterimg)
plt.imshow(afterimg)
plt.show()
print(sdl)
x=[i for i in range(1,500)]

plt.plot(x, np.array(sdl[0]), label = "Adaptive")
plt.plot(x, np.array(sdl[1]), label = "Static")
plt.legend()
plt.show()